![[Screenshot 2025-12-07 at 21.30.53.png]]


![[Screenshot 2025-12-07 at 21.29.45.png]]


![[Screenshot 2025-12-07 at 21.21.31.png]]
![[Screenshot 2025-12-07 at 21.22.24.png]]

- **LSM Trees**: RocksDB, LevelDB, Cassandra
    
- **Append-Only MVCC Storage**: PostgreSQL heap tables

- **Oracle UNDO + Redo**
    
- **ClickHouse parts**
    
- **Kafka logs**

# ğŸ± 1. What an SSTable _Really Is_

**SSTable = Sorted String Table**

- Immutable file
    
- Sorted by key
    
- Contains **data blocks**, **index block**, **filter block**, **footer**
    
- Designed for _sequential read_ and _fast lookup_
    

Think of it as:

[SSTable file]
  â”œâ”€â”€ Data Blocks (sorted key-value chunks)
  â”œâ”€â”€ Index Block (points to each data block)
  â”œâ”€â”€ Filter Block (Bloom Filter)
  â”œâ”€â”€ Metaindex Block
  â””â”€â”€ Footer (fixed size, last 48 bytes)


---

# ğŸ“ 2. What EXACTLY is inside an SST file (byte-level view)

Here's an actual **internal structure** like RocksDB/LevelDB:

+--------------------------------------------------------------+
| Data Block #1 (K/V entries)                                  |
+--------------------------------------------------------------+
| Data Block #2 (K/V entries)                                  |
+--------------------------------------------------------------+
| Data Block #3 (K/V entries)                                  |
+--------------------------------------------------------------+
| ...                                                          |
+--------------------------------------------------------------+
| Filter Block (Bloom filters for blocks)                      |
+--------------------------------------------------------------+
| Metaindex Block (pointers to filter block, etc.)             |
+--------------------------------------------------------------+
| Index Block (key â†’ block handle mappings)                    |
+--------------------------------------------------------------+
| Footer (16-byte magic + block handles + meta offsets)        |
+--------------------------------------------------------------+

SST files are typically 1â€“64 MB in size.

---

# ğŸ” 3. Data Block (the most important part)

Each block stores **many sorted K/V pairs**:

[Data Block]
+------------------------------+
| Restart Point #1             |  \
| Restart Point #2             |   > prefix compression
| Restart Point #3             |  /
+------------------------------+
| Key (partial) | Value        |
| Key (partial) | Value        |
| Key (partial) | Value        |
+------------------------------+
| Restart Count                 |
+------------------------------+

### Why â€œpartial keyâ€?

To reduce space:

- Store full key at restart points
    
- Store delta/prefix key between restart points
    

Example keys:

`user:0001 user:0002 user:0003 user:0004`

Storage:

Restart #1:  user:0001
Entry 2:     suffix("2")
Entry 3:     suffix("3")
Entry 4:     suffix("4")

---

# ğŸ¯ 4. Index Block

The index block maps each data block to its **key range**.

Example:

|Block|Smallest Key|Offset on Disk|
|---|---|---|
|1|user:0001|0x0000FA|
|2|user:0400|0x001234|
|3|user:0800|0x0028A0|

This lets the DB jump directly to the correct part of the SST.

---

# ğŸŒ¸ 5. Filter Block (Bloom Filters)

Avoids unnecessary disk reads.

Contains Bloom filters like:

`filter for [user:0000 â€“ user:03FF]
`filter for [user:0400 â€“ user:07FF]` 
`filter for [user:0800 â€“ user:0BFF]`

Query:

`GET user:0111    â†’ check Bloom filter    â†’ if filter says â€œNOâ€ â†’ skip data block`

Huge performance boost.

---

# ğŸ§© 6. Metaindex Block

Contains metadata like:

- pointer to filter block
    
- pointer to compression type
    
- version info
    

Simple key-value pairs.

---

# ğŸ§± 7. Footer (last 48 bytes)

Looks like:

[Index Block Offset | Index Block Size]        (16 bytes)
[MetaIndex Offset   | MetaIndex Size]          (16 bytes)
[Magic Number: SST signature]                  (8 bytes)


Magic number example:

`0x88 F2 3A E1 6B BD E2 41`

Footer lets DB open SST files backwards (from the end).

---

# ğŸ—‚ 8. How L0, L1, L2â€¦ Look in an LSM Tree

![[Screenshot 2025-12-07 at 22.52.40.png]]

**Level 0 (L0):**

- Files come directly from memtable flush
    
- Overlapping key ranges
    
- Many small SSTs
    
- Searching L0 means scanning multiple SST files
    

Example:

L0:
    file_001.sst  [A â€” F]
    file_002.sst  [C â€” M]
    file_003.sst  [A â€” Z]


Overlaps allowed.

---

**Level 1 (L1):**

- Non-overlapping key ranges
    
- Larger files (10â€“50 MB each)
    
- Results from compaction of L0
    

Example:

L1:
    file_010.sst  [A â€” D]
    file_011.sst  [E â€” H]
    file_012.sst  [I â€” M]
    file_013.sst  [N â€” Z]


Only **one file** per key range.

---

**Level 2+:**

- Even larger files
    
- No overlap within each level
    
- Compaction moves data downward
    

Example:

L2:
  file_100.sst   [A â€” H]
  file_101.sst   [I â€” Z]

L3:
  file_200.sst   [A â€” Z]  (hundreds of MB)


LSM Tree looks like:

L0:  many small overlapping files
L1:  fewer non-overlapping files
L2:  even fewer files, bigger
L3:  huge files


---

# ğŸ§  9. Retrieval Path (How a GET Works)

To read a key:

1. Check **memtable**
    
2. Check **immutable memtables**
    
3. Check **L0 SSTs** (search all overlapping)
    
4. Check **L1 SST** (only one file)
    
5. Check **lower levels** (1 file per level)
    

Within SST:

1. Use **Bloom filter** to skip blocks
    
2. Use **Index Block** to find block
    
3. Use **Data Block** to find key
    
4. Resolve version with sequence number