`WHERE HASH(uuid) % 10 = X` forces the DB to:

1. Read every row
    
2. Compute `HASH(uuid)`
    
3. Apply `% 10`
    
4. Then filter
    

That is **full table scan** territory.

Below are **correct, production-grade ways to make this fast**, depending on your database.

---

## 1ï¸âƒ£ Core principle (must understand)

### âŒ Slow

`WHERE HASH(uuid) % 10 = 3`

Why?

- Index is on `uuid`
    
- Youâ€™re querying **`HASH(uuid)`**
    
- DB cannot reverse the function â†’ index useless
    

### âœ… Fast rule

> **Precompute the expression and index it**

---

## 2ï¸âƒ£ BEST solution (works everywhere): **store the bucket**

### Step 1: Add a column

`bucket INT`

### Step 2: Fill it once

`UPDATE users SET bucket = HASH(uuid) % 10;`

### Step 3: Index it

`CREATE INDEX idx_users_bucket ON users(bucket);`

### Step 4: Query

`SELECT * FROM users WHERE bucket = 3;`

âœ… **O(log N)**  
âœ… Uses index  
âœ… Scales to billions of rows  
âœ… Used in sharding / sampling / load distribution systems

ðŸ’¡ This is how **Kafka, ClickHouse, BigQuery** style systems do it.

---

## 3ï¸âƒ£ If you use **PostgreSQL** (best DB for this)

Postgres supports **expression indexes**.

### Create index on the expression

`CREATE INDEX idx_users_hash_bucket ON users ((hashtext(uuid::text) % 10));`

### Query

`SELECT * FROM users WHERE hashtext(uuid::text) % 10 = 3;`

âœ… Index is used  
âš ï¸ Expression must match **exactly**

ðŸ“Œ Use this if:

- You **cannot change schema**
    
- Expression is stable
    

---

## 4ï¸âƒ£ If you use **MySQL 8+**

MySQL does **NOT** support expression indexes directly  
But it supports **generated columns**

### Step 1: Add generated column

`ALTER TABLE users ADD COLUMN bucket INT GENERATED ALWAYS AS (CRC32(uuid) % 10) STORED;`

### Step 2: Index it

`CREATE INDEX idx_users_bucket ON users(bucket);`

### Step 3: Query

`SELECT * FROM users WHERE bucket = 3;`

âœ… Fast  
âœ… Indexable  
âŒ Virtual column (`VIRTUAL`) will NOT work â†’ must be `STORED`

---

## 5ï¸âƒ£ Ultra-fast approach: **range instead of hash** (if acceptable)

If you only want **sampling**, hashing is overkill.

Example:

`WHERE uuid >= '20000000-0000-0000-0000-000000000000'   AND uuid <  '30000000-0000-0000-0000-000000000000'`

âœ… Uses index on `uuid`  
âœ… Zero computation  
âŒ Distribution less uniform

---

## 6ï¸âƒ£ Partitioning (when table is huge)

If `HASH(uuid) % 10` represents **shards**, then:

`PARTITION BY HASH(bucket) PARTITIONS 10`

Now:

`WHERE bucket = 3`

ðŸ‘‰ **Only 1 partition scanned**

This is how **high-traffic systems scale**
