![[Screenshot 2025-12-07 at 21.30.53.png]]


![[Screenshot 2025-12-07 at 21.29.45.png]]


![[Screenshot 2025-12-07 at 21.21.31.png]]
![[Screenshot 2025-12-07 at 21.22.24.png]]

- **LSM Trees**: RocksDB, LevelDB, Cassandra
    
- **Append-Only MVCC Storage**: PostgreSQL heap tables

- **Oracle UNDO + Redo**
    
- **ClickHouse parts**
    
- **Kafka logs**

# ðŸ”§ What Is a Memtable?

A **memtable** is an **in-memory sorted data structure**, usually:

- **Skiplist** (LevelDB, RocksDB default)
    
- **Balanced tree** (Cassandra uses a B+Tree-like structure)
    
- **Red-black tree**
    

It stores the **latest written key-value pairs**.

### Why it exists?

Disk writes are slow âš ï¸  
Random writes are _very_ slow âš ï¸

Memtable keeps new writes **in RAM**, which is:

- Fast
    
- Lock-free in many implementations
    
- Sorted automatically
    

Every write is appended to the **WAL (Write-Ahead Log)** for durability, then inserted into the memtable.

---

# ðŸ”¥ What Happens on INSERT or UPDATE?

### 1ï¸âƒ£ Client writes a key-value:

`PUT(user123, "Alice")`

### 2ï¸âƒ£ Database appends to the WAL (sequential disk write)

This guarantees durability.

### 3ï¸âƒ£ Then updates the Memtable

Memtable stores:

`user123 â†’ "Alice" (plus sequence number, tombstone flag, etc.)`

### 4ï¸âƒ£ Memtable keeps it sorted

So range reads and flush to SST files are easy.

---

# ðŸ§Š When Does the Memtable Flush?

The memtable is kept in RAM until:

- It becomes **full** (memory threshold reached, e.g., 64MB)
    
- Or system pressure
    
- Or manual flush command
    

Example threshold:

`memtable_size = 64 MB`

Once memtable reaches ~64MBâ€¦

ðŸ‘‰ It gets **frozen** and becomes an **immutable memtable**.  
ðŸ‘‰ A new active memtable is created.

---

# ðŸš€ How Flushing From Memtable â†’ SSTable Happens

### Step-by-step flushing process

---

## **1ï¸âƒ£ Memtable becomes immutable**

Current memtable:

- No longer accepts writes
    
- Becomes a _read-only_ snapshot of memory
    

A new memtable is created to take new writes.

---

## **2ï¸âƒ£ Background flush thread starts**

A background I/O thread takes the **immutable memtable**.

---

## **3ï¸âƒ£ The memtable is written to disk as an SSTable**

### SST (Sorted String Table) format:

- sorted keys
    
- values
    
- index blocks
    
- bloom filter
    
- footer
    

The memtable is **already sorted**, so writing is just a **sequential scan + write** (very fast!).

Example SSTable:

`[user001 â†’ Alice] [user002 â†’ Bob] [user003 â†’ Charlie] ...`


# ðŸ± 1. What an SSTable _Really Is_

**SSTable = Sorted String Table**

- Immutable file
    
- Sorted by key
    
- Contains **data blocks**, **index block**, **filter block**, **footer**
    
- Designed for _sequential read_ and _fast lookup_
    

Think of it as:

[SSTable file]
  â”œâ”€â”€ Data Blocks (sorted key-value chunks)
  â”œâ”€â”€ Index Block (points to each data block)
  â”œâ”€â”€ Filter Block (Bloom Filter)
  â”œâ”€â”€ Metaindex Block
  â””â”€â”€ Footer (fixed size, last 48 bytes)


---

# ðŸ“ 2. What EXACTLY is inside an SST file (byte-level view)

Here's an actual **internal structure** like RocksDB/LevelDB:

+--------------------------------------------------------------+
| Data Block #1 (K/V entries)                                  |
+--------------------------------------------------------------+
| Data Block #2 (K/V entries)                                  |
+--------------------------------------------------------------+
| Data Block #3 (K/V entries)                                  |
+--------------------------------------------------------------+
| ...                                                          |
+--------------------------------------------------------------+
| Filter Block (Bloom filters for blocks)                      |
+--------------------------------------------------------------+
| Metaindex Block (pointers to filter block, etc.)             |
+--------------------------------------------------------------+
| Index Block (key â†’ block handle mappings)                    |
+--------------------------------------------------------------+
| Footer (16-byte magic + block handles + meta offsets)        |
+--------------------------------------------------------------+

SST files are typically 1â€“64 MB in size.

---

# ðŸ” 3. Data Block (the most important part)

Each block stores **many sorted K/V pairs**:

[Data Block]
+------------------------------+
| Restart Point #1             |  \
| Restart Point #2             |   > prefix compression
| Restart Point #3             |  /
+------------------------------+
| Key (partial) | Value        |
| Key (partial) | Value        |
| Key (partial) | Value        |
+------------------------------+
| Restart Count                 |
+------------------------------+

### Why â€œpartial keyâ€?

To reduce space:

- Store full key at restart points
    
- Store delta/prefix key between restart points
    

Example keys:

`user:0001 user:0002 user:0003 user:0004`

Storage:

Restart #1:  user:0001
Entry 2:     suffix("2")
Entry 3:     suffix("3")
Entry 4:     suffix("4")

---

# ðŸŽ¯ 4. Index Block

The index block maps each data block to its **key range**.

Example:

|Block|Smallest Key|Offset on Disk|
|---|---|---|
|1|user:0001|0x0000FA|
|2|user:0400|0x001234|
|3|user:0800|0x0028A0|

This lets the DB jump directly to the correct part of the SST.

---

# ðŸŒ¸ 5. Filter Block (Bloom Filters)

Avoids unnecessary disk reads.

Contains Bloom filters like:

`filter for [user:0000 â€“ user:03FF]
`filter for [user:0400 â€“ user:07FF]` 
`filter for [user:0800 â€“ user:0BFF]`

Query:

`GET user:0111    â†’ check Bloom filter    â†’ if filter says â€œNOâ€ â†’ skip data block`

Huge performance boost.

---

# ðŸ§© 6. Metaindex Block

Contains metadata like:

- pointer to filter block
    
- pointer to compression type
    
- version info
    

Simple key-value pairs.

---

# ðŸ§± 7. Footer (last 48 bytes)

Looks like:

[Index Block Offset | Index Block Size]        (16 bytes)
[MetaIndex Offset   | MetaIndex Size]          (16 bytes)
[Magic Number: SST signature]                  (8 bytes)


Magic number example:

`0x88 F2 3A E1 6B BD E2 41`

Footer lets DB open SST files backwards (from the end).

---

# ðŸ—‚ 8. How L0, L1, L2â€¦ Look in an LSM Tree

![[Screenshot 2025-12-07 at 22.52.40.png]]

**Level 0 (L0):**

- Files come directly from memtable flush
    
- Overlapping key ranges
    
- Many small SSTs
    
- Searching L0 means scanning multiple SST files
    

Example:

L0:
    file_001.sst  [A â€” F]
    file_002.sst  [C â€” M]
    file_003.sst  [A â€” Z]


Overlaps allowed.

---

**Level 1 (L1):**

- Non-overlapping key ranges
    
- Larger files (10â€“50 MB each)
    
- Results from compaction of L0
    

Example:

L1:
    file_010.sst  [A â€” D]
    file_011.sst  [E â€” H]
    file_012.sst  [I â€” M]
    file_013.sst  [N â€” Z]


Only **one file** per key range.

---

**Level 2+:**

- Even larger files
    
- No overlap within each level
    
- Compaction moves data downward
    

Example:

L2:
  file_100.sst   [A â€” H]
  file_101.sst   [I â€” Z]

L3:
  file_200.sst   [A â€” Z]  (hundreds of MB)


LSM Tree looks like:

L0:  many small overlapping files
L1:  fewer non-overlapping files
L2:  even fewer files, bigger
L3:  huge files


---

# ðŸ§  9. Retrieval Path (How a GET Works)

Letâ€™s say the user calls:

`value = db->Get("user:12345");`

We will walk through **every stage** of the read path.

---

## ðŸ¥‡ Step 1 â€” Query the Memtable (RAM)

ðŸ”¥ Always checked first because:

- It has **newest writes**
    
- Itâ€™s in **RAM** â†’ fastest access
    

Memtable is usually:

- Skiplist (LevelDB)
    
- Red-black tree (some implementations)
    
- B-tree or ART (modern systems)
    

### What happens?

1. Search the memtable like a sorted map.
    
2. If key exists:
    
    - Return the associated value (or tombstone)
        
    - STOP â†’ done.
        

If not found:

- Check **immutable memtables**.
    

---

## Step 2 â€” Immutable Memtables (Not Yet Flushed)

When a memtable is full, it becomes **immutable** and a background thread flushes it to L0 SSTables.

Immutable tables:

- Are sorted
    
- Are searched the same way as the active memtable
    

If key is found:

- Return value
    
- STOP â†’ done
    

If not found:

- Proceed to L0.
    

---

## Step 3 â€” Search L0 SSTables

### WHY is L0 special?

- Many small files (flushes)
    
- **Key ranges overlap**
    
- So multiple files _may_ contain the same key
    

### ORDER:

ðŸ”½ **Newest â†’ Oldest**

Because newer files contain higher **sequence numbers**, meaning newer versions.

### For each L0 file:

1. **Check Bloom filter**
    
    - If Bloom filter says "not present": skip file completely (very fast)
        
2. **If Bloom filter might match â†’ binary-search the Index Block**
    
3. Find the correct Data Block
    
4. Lookup key inside the Data Block
    
5. If key found:
    
    - Check sequence numbers
        
    - Return the newest visible version
        
    - STOP â†’ done
        

If not found in any L0 file:

- Move to L1.
    

---

## Step 4 â€” Search Level 1 SSTables

### KEY PROPERTY OF L1 AND BELOW:

ðŸ“Œ **Non-overlapping key ranges**

This gives a huge optimization:

ðŸ‘‰ There is **exactly one SST file at L1** that _can possibly_ contain this key.

### Process:

1. Binary-search the file metadata for key ranges
    
2. Jump to the exact SST file
    
3. Perform:
    
    - Bloom filter â†’ skip or continue
        
    - Index Block lookup
        
    - Data Block lookup
        

If found:

- Return value
    
- STOP â†’ done
    

If not found:

- Move to L2.
    

---

## Step 5 â€” Search Levels L2, L3, â€¦ Ln

Each lower level:

- Has **bigger files**
    
- Ranges do not overlap inside the level
    
- So only **1 file per level** needs to be checked
    

(Sometimes 0 files if keyâ€™s range doesnâ€™t exist.)

For each level:

1. Binary-search file list
    
2. Check Bloom filter
    
3. Check index â†’ block â†’ record
    

If found:

- Return value
    
- DONE
    

If not found:

- Continue downward


# Tuple Layout & Tuple Header 

## 1. What Is a Tuple?

A **tuple** = one **row** stored inside a **page/block** in a database.  
Example: a table row

`(id=10, name="Alice", age=25)`

In storage, this becomes:

`[TUPLE HEADER][NULL BITMAP][VARIABLE-LENGTH AREA][FIXED-LENGTH AREA]`

---


# 1. Page Layout (where tuples live)

A typical page (e.g., PostgreSQL 8KB, Oracle 16KB) contains:

+-------------------------+
| Page Header             |
+-------------------------+
| Item/Line Pointers      |
+-------------------------+
| Tuples (physical data)  |
+-------------------------+
| Free Space              |
+-------------------------+


The page header tracks:

- page LSN / checksum
    
- number of tuples
    
- free space offset
    
- MVCC metadata
    

Item pointers:

- point to each tupleâ€™s **offset** inside the page
    
- allow tuples to move without breaking references
    

---

# 2. Tuple Layout (Row Layout)

A tuple contains:

+------------------------------+
| Tuple Header                 |
+------------------------------+
| NULL Bitmap (optional)       |
+------------------------------+
| Variable-length data         |
+------------------------------+
| Fixed-length data            |
+------------------------------+
| Padding (alignment)          |
+------------------------------+

---

# 3. Tuple Header â€” What Is Inside?

A **tuple header** stores metadata so the DB can manage MVCC, indexing, nulls, and versioning.  
PostgreSQL example:

TupleHeader {
    xmin      // creating transaction ID
    xmax      // deleting or updating txn ID
    xvac      // vacuum ID (old)
    ctid      // tuple identifier (version chaining)
    infomask  // flags: nulls? varlen? keys?
    natts     // number of attributes
    ... other MVCC/control bits
}


### What Tuple Header Encodes

|Field|Meaning|
|---|---|
|**xmin**|Transaction that created this version|
|**xmax**|Transaction that deleted/updated it|
|**ctid**|If updated â†’ points to new tuple version (version chain)|
|**NULL bitmap**|Bitmask indicating which columns are NULL|
|**VARLENA flags**|Flags for variable-length types|
|**Visibility flags**|Helps MVCC determine visible versions|

---

# 4. Why Is Tuple Header Needed?

It enables **MVCC** and prevents blocking:

- By checking `(xmin, xmax)` against the snapshot, DB knows **which version** of the row is visible.
    
- When updating, DB **creates a new tuple**, links via `ctid`, and marks old versionâ€™s `xmax`.
    
- Without tuple header, DB cannot provide snapshot isolation.

## Version chain
When a row is updated, the DB forms a **version chain**:

`[Tuple V1] -> [Tuple V2] -> [Tuple V3] -> ...`

This is literally a **linked list** stored inside the page.

### Example:

Before update:

`ctid = (block 12, offset 5)   // points to itself`

After update:

`V1.ctid = (12,5) â†’ (12,9)   // new version V2.ctid = (12,9) â†’ itself`

Readers follow the chain until they find a version **visible** at their snapshot SCN.


## How MVCC Chooses Which Version You See
### Transaction T1 begins with snapshot SCN = 100

Versions available:

`V1: xmin = 50,  xmax = 120 V2: xmin = 120, xmax = 0`

Interpretation:

- V1 created earlier, deleted by txn 120
    
- V2 created by txn 120
    

At SCN = 100:

- `120 > 100` â†’ T1 cannot see V2 (created in the future)
    
- `xmax of V1 = 120 > 100` â†’ delete is in the future â†’ V1 is still valid
    

So T1 sees **Version 1**.


# 5. Tuple Storage Example

### Schema

CREATE TABLE users (
    id INT,
    name TEXT,
    age INT
);

### Tuple Stored

[Header]
    xmin = 100
    xmax = 0
    ctid = (0,10)
    null_bitmap = 0b000  (no nulls)

[Varlen Area]
    "Alice"

[Fixed Area]
    id = 10
    age = 25


---

# 6. Update Example With Full MVCC Logic

## Step 1 â€” Original row

`Row V1: xmin = 50 xmax = 0 ctid = self`

## Step 2 â€” T2 updates row at SCN = 120

DB:

1. Copies V1 into UNDO (Oracle) or keeps V1 inline (Postgres)
    
2. Creates new version V2
    
3. Sets V1.xmax = 120
    
4. Sets V1.ctid â†’ V2
    

`V1:     xmin = 50     xmax = 120     ctid = (block,offset_of_V2) V2:     xmin = 120     xmax = 0     ctid = self`

### Visibility rules:

- Readers with **snapshot < 120** â†’ see V1
    
- Readers with **snapshot â‰¥ 120** â†’ see V2
    

That is MVCC.

---

# 7. Delete Example

DELETE marks the row as â€œnot visible anymoreâ€ by setting:

`xmax = deleting_txn`

But the row isnâ€™t removed immediately (to support old snapshots).


## 8. NULL Bitmap

If any columns can be NULL, DB adds a **bitmap** with 1 bit per column:

- `1 = NULL`
    
- `0 = NOT NULL`
    

Bitmap is needed because storing actual `NULL` values wastes space.

### Example

table:

`CREATE TABLE users(     id INT,     name TEXT,     age INT,     city TEXT  -- can be null );`

row:

`(1, 'Tom', 25, NULL)`

NULL bitmap (4 columns â†’ 1 byte enough):

`Columns:  id  name age city Bitmap:   0    0    0    1`

Meaning: `city` is NULL.

Bitmap goes immediately after header.

---

## 9. Variable-length Attributes (varlen)

Types like:

- `TEXT`, `VARCHAR`, `BYTEA`
    
- arrays
    
- JSON
    
- XML
    
- large objects
    

All go in the **varlen section**.

### Example (PostgreSQL)

Tuple:

`('Tom', 25)`

storage:

`varlen:    name = 'Tom'       length prefix (1 byte or 4 bytes)      data bytes ('T','o','m') fixed:    age = INT: 25`

Varlen fields store _length + data_.

If very large â†’ stored outside (TOAST), and tuple stores only a pointer.

---

## 10. Fixed-length Attributes

Types like:

- `INT`
    
- `BIGINT`
    
- `FLOAT`
    
- `DATE`
    
- `BOOLEAN`
    
- small enums
    

These are stored after the variable-length area.

### Example

If your row is:

`id INT = 1 age INT = 25`

These go into the fixed-length zone:

`00 00 00 01   (id = 1) 00 00 00 19   (age = 25)`

Fixed-length fields always take the same number of bytes, no matter the value.

---

## 11. Padding / Alignment
![[Screenshot 2025-12-08 at 23.07.01.png]]
![[Screenshot 2025-12-08 at 23.07.27.png]]
![[Screenshot 2025-12-08 at 23.07.48.png]]


CPUs access memory faster when values are aligned to:

- 2 bytes
    
- 4 bytes
    
- 8 bytes boundaries
    

Databases add **padding** so fixed-length fields start aligned.

### Example

Suppose:

- varlen part is 5 bytes
    
- integer requires 4-byte alignment
    

DB adds **3 padding bytes** so the integer starts at an address divisible by 4.

`Varlen: 5 bytes Padding: 3 bytes Fixed: INT (4 bytes)`

This makes the tuple longer but improves CPU performance.
## 1. `SELECT pg_column_size(ROW(1,2,3));` â†’ 36 bytes

### Types inferred:

`1 â†’ int4 2 â†’ int4 3 â†’ int4`

### Per-field sizes:

- `int4` = **4 bytes**
    
- 3 fields â†’ 12 bytes of actual data
    

### Tuple metadata:

|Component|Size|
|---|---|
|Heap tuple header|23 bytes|
|Alignment padding|1 byte|
|Data|12 bytes|
|**Total**|**36 bytes**|

âœ” Why 1 byte of padding?  
PostgreSQL aligns 4-byte integers to 4-byte boundaries after the 23-byte tuple header.

So:

`23 (header) + 1 padding = 24 â†’ aligned to 4 bytes   24 + 12 (data) = 36`

---

## 2. `SELECT pg_column_size(ROW(1::int2,2::int2,3::int2));` â†’ 30 bytes

### Types:

All `int2` (smallint = 2 bytes)

### Data:

`2 + 2 + 2 = 6 bytes`

### Alignment:

Postgres aligns **int2 to 2-byte boundaries**.

Tuple header: 23 bytes  
23 is odd â†’ 1 byte padding to align to 2 bytes.

Total:

`23 + 1 + 6 = 30 bytes`

âœ” No alignment required between fields because `int2` only needs 2-byte alignment.

---

## 3. `SELECT pg_column_size(ROW('a'::char, 2::int2, 'b'::char, 4::int4, 'c'::char, 8::int8));` â†’ 48 bytes

Now rows have mixed alignment requirements:

|Field|Type|Size|Alignment|
|---|---|---|---|
|'a'|char(1)|1|1 byte|
|2|int2|2|2 bytes|
|'b'|char(1)|1|1 byte|
|4|int4|4|**4 bytes**|
|'c'|char(1)|1|1 byte|
|8|int8|8|**8 bytes** (biggest alignment)|

### Alignment rules:

The moment you hit `int4` and `int8`, PostgreSQL inserts padding to align the memory offset:

Breakdown:

|Description|Size|
|---|---|
|Tuple header|23|
|Align to 2 bytes (because next field int2)|+1|
|char(1)|+1|
|align to 2 bytes|+1|
|int2|+2|
|char(1)|+1|
|align to 4 bytes (for int4)|+1|
|int4|+4|
|char(1)|+1|
|align to 8 bytes (for int8)|+3|
|int8|+8|
|**Total**|**48 bytes**|

âœ” Most bloat comes from aligning before int4 and int8.

---

## **4. `SELECT pg_column_size(ROW(8::int8, 4::int4, 2::int2, 'a'::char, 'b'::char, 'c'::char));` â†’ 44 bytes

Same fields as example #3, but **different order**, therefore different padding.

This is the important lesson:

### **Changing field order changes total tuple size because alignment changes.**

Breakdown:

|Field|Type|Alignment|Notes|
|---|---|---|---|
|int8|8 bytes|aligned immediately after header||
|int4|4 bytes|naturally aligned after int8||
|int2|2 bytes|aligned||
|char|1 byte|no alignment needed||
|char|1 byte|no alignment needed||
|char|1 byte|no alignment needed||

---
![[Screenshot 2025-12-08 at 23.11.28.png]]
