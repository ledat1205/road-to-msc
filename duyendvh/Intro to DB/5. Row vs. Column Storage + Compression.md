![[Screenshot 2025-12-10 at 22.20.36.png]]
![[Screenshot 2025-12-10 at 22.58.40.png]]![[Screenshot 2025-12-10 at 23.17.49.png]]![[Screenshot 2025-12-10 at 23.24.27.png]]![[Screenshot 2025-12-10 at 23.26.18.png]]

![[Screenshot 2025-12-10 at 23.28.23.png]]![[Screenshot 2025-12-10 at 23.34.16.png]]
## **Solution: Dictionary Compression**

Instead of storing long strings directly in the tuple, store a **small integer ID**.

### Step 1 â€” Build a dictionary (unique values)

Example column:

`"USA" "Vietnam" "USA" "France" "Vietnam"`

Dictionary created:

|ID|Value|
|---|---|
|1|USA|
|2|Vietnam|
|3|France|

### Step 2 â€” Replace column values with a **fixed 32-bit integer**

Column becomes:

`1 2 1 3 2`

Now every value is **just 4 bytes** (32-bit int), no matter how long the original string is.

![[Screenshot 2025-12-10 at 23.34.36.png]]
![[Screenshot 2025-12-10 at 23.35.55.png]]
![[Screenshot 2025-12-10 at 23.39.20.png]]
![[Screenshot 2025-12-10 at 23.41.28.png]]
https://www.youtube.com/watch?v=1j8SdS7s_NY&t=705s
### Parquet â€” The #1 Data Lake Format

### **1ï¸âƒ£ Columnar Storage**

- Stores data **by column**, not by row.
    
- Scans only needed columns â†’ **10Ã—â€“100Ã— less I/O**.
    

### **2ï¸âƒ£ High Compression**

- Per-column compression: RLE, dictionary, delta, bit-packing, Snappy, ZSTD.
    
- Similar values â†’ great compression â†’ **CSV 1GB â†’ Parquet ~120MB**.
    

### **3ï¸âƒ£ Predicate Pushdown**

- Stores min/max/null stats per column.
    
- Engines skip entire row groups â†’ **huge speedups**.
    

### **4ï¸âƒ£ Self-Describing Schema**

- Schema, types, encoding, stats all inside the file.
    
- Supports schema evolution.
    

### **5ï¸âƒ£ Vectorized Execution**

- Columnar blocks map to SIMD â†’ **CPU processes thousands of values at once**.
    

### **6ï¸âƒ£ Row Groups & Pages**

- Organized for **random access**, skipping, parallel reads.
    

### **7ï¸âƒ£ Splittable**

- Can be split at row group boundaries â†’ perfect for distributed systems.
    

### **8ï¸âƒ£ Immutable-Friendly**

- Write-once, append-only â†’ ideal for S3/GCS/HDFS data lakes.
    

### **9ï¸âƒ£ Widest Ecosystem Support**

- Works with Spark, Trino, BigQuery, DuckDB, Snowflake, Athena, etc.

![[Screenshot 2025-12-10 at 23.47.42.png]]![[Screenshot 2025-12-10 at 23.51.09.png]]![[Screenshot 2025-12-10 at 23.53.15.png]]
### ğŸŒŸ Summary Table

|Granularity|What is compressed|Systems|Pros|Cons|
|---|---|---|---|---|
|**Block-level**|Entire page|InnoDB, PG, SQLite|Great compression|Must decompress whole page|
|**Tuple-level**|Entire row|PostgreSQL, SQL Server|Good for OLTP|Canâ€™t use cross-row redundancy|
|**Attribute-level**|Large individual values|PG TOAST, MySQL LOB|Only compress big fields|Overflow reads|
|**Column-level**|Whole column|Parquet, ORC, ClickHouse|Best compression & speed|Bad for OLTP|
![[Screenshot 2025-12-10 at 23.57.07.png]]![[Screenshot 2025-12-11 at 00.03.59.png]]
![[Screenshot 2025-12-11 at 00.05.00.png]]![[Screenshot 2025-12-11 at 00.07.42.png]]
![[Screenshot 2025-12-11 at 00.11.33.png]]
![[Screenshot 2025-12-11 at 00.12.37.png]]
![[Screenshot 2025-12-11 at 00.13.53.png]]
# âœ… What Is Bitmap Encoding?

A **bitmap** (bitset) encodes a set of integers using **1 bit per value**:

- `bit = 1` â†’ value exists
    
- `bit = 0` â†’ value doesn't exist
    

This is extremely fast for:

- filtering
    
- intersections
    
- unions
    
- counting distinct values
    
- membership queries
    

ClickHouse uses **Roaring Bitmaps**, a compressed bitmap format.

---

# ğŸ¯ Why Bitmap Encoding?

Because analytic queries often ask:

- â€œusers who visited page A AND page Bâ€
    
- â€œevents for user_id IN (â€¦)â€
    
- â€œhow many unique users?â€
    
- â€œfilter rows where country_id âˆˆ {3,7,9}â€
    

Bitmap operations can run on **tens of millions of integers in microseconds**.

---

# â­ Bitmap Encoding in ClickHouse

ClickHouse implements:

- **Sparse bitmaps** using **RoaringBitmaps**
    
- Functions:
    
    - `bitmapBuild`
        
    - `bitmapContains`
        
    - `bitmapAnd`
        
    - `bitmapOr`
        
    - `bitmapCardinality`
        
    - `groupBitmapInsert`
        
    - Aggregate function: `groupBitmapState`
        

Storage type:

- `AggregateFunction(groupBitmap, UInt32)`
    
- `AggregateFunction(groupBitmap, UInt64)`
    

---

# ğŸ”§ How a Bitmap Works Internally

(Using **Roaring Bitmap**, the format used by ClickHouse)

For integers, ClickHouse stores bitmaps in **containers**, grouped by high 16 bits:

`Integer: 0xAAAA BBBB   High bits (AAAA) => container index   Low bits  (BBBB) => bit position inside container`

Example integers:

`5, 7, 1000, 65540`

Decompose:

|Value|High 16 bits|Low 16 bits|
|---|---|---|
|5|0|5|
|7|0|7|
|1000|0|1000|
|65540|1|4|

So bitmap becomes:

`Container 0 â†’ bits for [5,7,1000] Container 1 â†’ bits for [4]`

---

# â­ Roaring Compresses Each Container

For each container:

ğŸ“Œ If dense (many bits 1) â†’ **bitmap container**  
ğŸ“Œ If sparse (few bits 1) â†’ **array container**  
ğŸ“Œ If small ranges â†’ **run container**

This gives huge compression.

Example:

`Values: 1, 2, 3, 4, 1000000`

Containers:

- container 0 â†’ [1,2,3,4] â†’ run-length encoded
    
- container 15 â†’ [16960] (1000000 >> 16 = 15)
    

Compressed size might be 20â€“40 bytes.

---

# ğŸ”¥ Example: Bitmap Encoding in ClickHouse

`SELECT bitmapBuild([1,5,7,1000]) AS bm;`

Returns a bitmap object (binary).

Check membership:

`SELECT bitmapContains(bitmapBuild([1,5,7]), 5); -- 1`

Union:

`SELECT bitmapCardinality(bitmapOr(     bitmapBuild([1,2,3]),     bitmapBuild([3,4,5]) )); -- 5`

Intersection:

`SELECT bitmapAnd(     bitmapBuild([1,2,3]),     bitmapBuild([3,4,5]) ); -- [3]`

Count distinct efficiently:

`SELECT groupBitmapMergeState(bitmapState) FROM (     SELECT groupBitmapState(user_id) AS bitmapState     FROM events     GROUP BY date );`

This is **much faster** than `uniqExact` for large sets.

---

# ğŸ§  Why Bitmap Encoding Is Great (Especially in ClickHouse)

### âœ” Fast Set Operations (SIMD-accelerated)

Bitmap AND/OR/XOR â†’ bitwise ops on CPU â†’ **billions of values per second**

### âœ” Efficient for repeated filtering

Useful for â€œprecomputed segments,â€ e.g., users who:

- bought product A
    
- visited page B
    
- live in region C
    

### âœ” Excellent compression

Roaring bitmaps compresses sparse data 10Ã—â€“100Ã—.

---

# ğŸ§ª Real Example: How ClickHouse Stores Bitmaps

Table:

`CREATE TABLE user_segments (     segment_id UInt32,     users AggregateFunction(groupBitmap, UInt32) ) ENGINE = AggregatingMergeTree() ORDER BY segment_id;`

Insert:

`INSERT INTO user_segments SELECT 1, groupBitmapState(toUInt32(user_id)) FROM events WHERE action = 'login';`

Stored on disk as:

- binary RoaringBitmap payload
    
- compressed per-part with LZ4/ZSTD