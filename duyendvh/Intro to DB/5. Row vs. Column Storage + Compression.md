![[Screenshot 2025-12-10 at 22.20.36.png]]
![[Screenshot 2025-12-10 at 22.58.40.png]]![[Screenshot 2025-12-10 at 23.17.49.png]]![[Screenshot 2025-12-10 at 23.24.27.png]]![[Screenshot 2025-12-10 at 23.26.18.png]]

![[Screenshot 2025-12-10 at 23.28.23.png]]![[Screenshot 2025-12-10 at 23.34.16.png]]
## **Solution: Dictionary Compression**

Instead of storing long strings directly in the tuple, store a **small integer ID**.

### Step 1 â€” Build a dictionary (unique values)

Example column:

`"USA" "Vietnam" "USA" "France" "Vietnam"`

Dictionary created:

|ID|Value|
|---|---|
|1|USA|
|2|Vietnam|
|3|France|

### Step 2 â€” Replace column values with a **fixed 32-bit integer**

Column becomes:

`1 2 1 3 2`

Now every value is **just 4 bytes** (32-bit int), no matter how long the original string is.

![[Screenshot 2025-12-10 at 23.34.36.png]]
![[Screenshot 2025-12-10 at 23.35.55.png]]
![[Screenshot 2025-12-10 at 23.39.20.png]]
![[Screenshot 2025-12-10 at 23.41.28.png]]
https://www.youtube.com/watch?v=1j8SdS7s_NY&t=705s

![[Screenshot 2025-12-10 at 23.47.42.png]]![[Screenshot 2025-12-10 at 23.51.09.png]]![[Screenshot 2025-12-10 at 23.53.15.png]]
### ðŸŒŸ Summary Table

|Granularity|What is compressed|Systems|Pros|Cons|
|---|---|---|---|---|
|**Block-level**|Entire page|InnoDB, PG, SQLite|Great compression|Must decompress whole page|
|**Tuple-level**|Entire row|PostgreSQL, SQL Server|Good for OLTP|Canâ€™t use cross-row redundancy|
|**Attribute-level**|Large individual values|PG TOAST, MySQL LOB|Only compress big fields|Overflow reads|
|**Column-level**|Whole column|Parquet, ORC, ClickHouse|Best compression & speed|Bad for OLTP|