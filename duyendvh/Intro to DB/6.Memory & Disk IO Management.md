https://15445.courses.cs.cmu.edu/fall2024/slides/06-bufferpool.pdf
![[Screenshot 2025-12-11 at 12.33.34.png]]
![[Screenshot 2025-12-11 at 12.34.47.png]]
![[Screenshot 2025-12-11 at 12.42.49.png]]
# ✅ **1. Sorting + Join Buffers**

Temporary memory areas used by the DB engine to execute:

- `ORDER BY`
    
- `GROUP BY`
    
- `HASH JOIN`
    
- `MERGE JOIN`
    

### **How it works**

- If sorting/joining fits _inside_ the buffer → done in RAM → FAST.
    
- If it **exceeds** the buffer → spilled to **temporary disk files** → SLOW.
    

### **Examples**

### **MySQL**

- `sort_buffer_size`
    
- `join_buffer_size`
    

`SELECT * FROM orders ORDER BY created_at;`

MySQL allocates a `sort_buffer` for the thread.  
If the buffer is 2MB and sort requires 10MB → 8MB goes to temp disk.

### **PostgreSQL**

- `work_mem` (applies to each sort/join node)
    

`SET work_mem = '64MB';`

A hash join will use up to 64MB before spilling to `/tmp`.

---

# ✅ **2. Query Caches**

Stores **query plans or results** to avoid recomputing work.

### **Mechanism**

There are two types:

### **A. Result Cache (stores output)**

Example: MySQL 5.x Query Cache (now removed due to problems)

- Key = SQL string
    
- Value = resultset
    
- Invalidated when any table changes (makes it useless for OLTP)
    

### **B. Plan Cache (stores execution plans)**

This is used by PostgreSQL, MySQL, MSSQL, Oracle.

- Purpose: Skip query planning.
    
- Plans reused when SQL is parameterized.
    

### **Example (PostgreSQL)**

Prepared statement uses plan cache:

`PREPARE q AS SELECT * FROM users WHERE id = $1; EXECUTE q(5);`

Postgres reuses the same query plan → faster.

### **Example (MySQL 8)**

MySQL has a **prepared statement cache** and **statement digest cache**.

---

# ✅ **3. Maintenance Buffers**

Used for **background tasks**:

- Vacuum (PostgreSQL)
    
- Checkpointing
    
- Index building / index merging
    
- ANALYZE / statistics collection
    

### **How it works**

Internal threads allocate memory to perform maintenance without interfering with query buffers.

### **Examples**

### **PostgreSQL**

- `maintenance_work_mem`
    

Used by:

- VACUUM
    
- CREATE INDEX
    
- ALTER TABLE ADD FOREIGN KEY
    

`SET maintenance_work_mem = '1GB';`

Creating an index will use up to 1GB RAM before spilling.

### **MySQL (InnoDB)**

- `innodb_change_buffer`
    
- Stores changes to secondary indexes to apply later.
    
- Speeds up writes by deferring index maintenance.
    

---

# ✅ **4. Log Buffers**

Memory used to store **WAL / redo logs** _before_ flushing to disk.

### **Mechanism (general)**

- All writes go into **memory log buffer**
    
- Periodically flushed to disk (fsync)
    
- Crash-safe because logs reach disk before the data pages
    

### **Examples**

### **MySQL InnoDB**

- `innodb_log_buffer_size`
    

Workflow:

1. INSERT/UPDATE → write to log buffer
    
2. Periodically flushed to `ib_logfile0`, `ib_logfile1`
    

`SET GLOBAL innodb_log_buffer_size = 256*1024*1024;`

Large buffer helps bulk INSERT.

### **PostgreSQL**

- WAL buffer
    

Setting: `wal_buffers`

Data flows:

Query → WAL buffer (RAM) → WAL segment (disk) → replication

---

# ✅ **5. Dictionary Caches**

Metadata caches:

- table definitions
    
- index metadata
    
- column info
    
- statistics
    
- privilege caches
    

These avoid repeatedly reading metadata from disk.

### **Examples**

### **MySQL InnoDB**

- Table definition cache
    
- Adaptive hash index
    
- Data dictionary cache
    

When you run:

`SELECT * FROM orders;`

MySQL must load:

- table structure
    
- index definitions
    
- field metadata
    

If cached → instant  
If not → must load from `.frm`/data dictionary → slow

### **PostgreSQL**

PostgreSQL stores metadata in normal tables (`pg_class`, `pg_attribute`) but caches them in shared memory.

---
