https://15445.courses.cs.cmu.edu/fall2024/slides/06-bufferpool.pdf
![[Screenshot 2025-12-11 at 12.33.34.png]]
![[Screenshot 2025-12-11 at 12.34.47.png]]
![[Screenshot 2025-12-11 at 12.42.49.png]]
# âœ… **1. Sorting + Join Buffers**

Temporary memory areas used by the DB engine to execute:

- `ORDER BY`
    
- `GROUP BY`
    
- `HASH JOIN`
    
- `MERGE JOIN`
    

### **How it works**

- If sorting/joining fits _inside_ the buffer â†’ done in RAM â†’ FAST.
    
- If it **exceeds** the buffer â†’ spilled to **temporary disk files** â†’ SLOW.
    

### **Examples**

### **MySQL**

- `sort_buffer_size`
    
- `join_buffer_size`
    

`SELECT * FROM orders ORDER BY created_at;`

MySQL allocates a `sort_buffer` for the thread.  
If the buffer is 2MB and sort requires 10MB â†’ 8MB goes to temp disk.

### **PostgreSQL**

- `work_mem` (applies to each sort/join node)
    

`SET work_mem = '64MB';`

A hash join will use up to 64MB before spilling to `/tmp`.

---

# âœ… **2. Query Caches**

Stores **query plans or results** to avoid recomputing work.

### **Mechanism**

There are two types:

### **A. Result Cache (stores output)**

Example: MySQL 5.x Query Cache (now removed due to problems)

- Key = SQL string
    
- Value = resultset
    
- Invalidated when any table changes (makes it useless for OLTP)
    

### **B. Plan Cache (stores execution plans)**

This is used by PostgreSQL, MySQL, MSSQL, Oracle.

- Purpose: Skip query planning.
    
- Plans reused when SQL is parameterized.
    

### **Example (PostgreSQL)**

Prepared statement uses plan cache:

`PREPARE q AS SELECT * FROM users WHERE id = $1; EXECUTE q(5);`

Postgres reuses the same query plan â†’ faster.

### **Example (MySQL 8)**

MySQL has a **prepared statement cache** and **statement digest cache**.

---

# âœ… **3. Maintenance Buffers**

Used for **background tasks**:

- Vacuum (PostgreSQL)
    
- Checkpointing
    
- Index building / index merging
    
- ANALYZE / statistics collection
    

### **How it works**

Internal threads allocate memory to perform maintenance without interfering with query buffers.

### **Examples**

### **PostgreSQL**

- `maintenance_work_mem`
    

Used by:

- VACUUM
    
- CREATE INDEX
    
- ALTER TABLE ADD FOREIGN KEY
    

`SET maintenance_work_mem = '1GB';`

Creating an index will use up to 1GB RAM before spilling.

### **MySQL (InnoDB)**

- `innodb_change_buffer`
    
- Stores changes to secondary indexes to apply later.
    
- Speeds up writes by deferring index maintenance.
    

---

# âœ… **4. Log Buffers**

Memory used to store **WAL / redo logs** _before_ flushing to disk.

### **Mechanism (general)**

- All writes go into **memory log buffer**
    
- Periodically flushed to disk (fsync)
    
- Crash-safe because logs reach disk before the data pages
    

### **Examples**

### **MySQL InnoDB**

- `innodb_log_buffer_size`
    

Workflow:

1. INSERT/UPDATE â†’ write to log buffer
    
2. Periodically flushed to `ib_logfile0`, `ib_logfile1`
    

`SET GLOBAL innodb_log_buffer_size = 256*1024*1024;`

Large buffer helps bulk INSERT.

### **PostgreSQL**

- WAL buffer
    

Setting: `wal_buffers`

Data flows:

Query â†’ WAL buffer (RAM) â†’ WAL segment (disk) â†’ replication

---

# âœ… **5. Dictionary Caches**

Metadata caches:

- table definitions
    
- index metadata
    
- column info
    
- statistics
    
- privilege caches
    

These avoid repeatedly reading metadata from disk.

### **Examples**

### **MySQL InnoDB**

- Table definition cache
    
- Adaptive hash index
    
- Data dictionary cache
    

When you run:

`SELECT * FROM orders;`

MySQL must load:

- table structure
    
- index definitions
    
- field metadata
    

If cached â†’ instant  
If not â†’ must load from `.frm`/data dictionary â†’ slow

### **PostgreSQL**

PostgreSQL stores metadata in normal tables (`pg_class`, `pg_attribute`) but caches them in shared memory.

---

![[Screenshot 2025-12-11 at 19.05.56.png]]

![[Screenshot 2025-12-11 at 19.05.37.png]]

![[Screenshot 2025-12-11 at 19.04.18.png]]



![[Screenshot 2025-12-11 at 18.56.14.png]]
# â­ What is Memory-Mapped I/O?

Memory-mapped I/O means:

`OS maps a file from disk â†’ directly into process memory. The DBMS reads/writes by touching memory addresses. The OS handles actual I/O behind the scenes.`

At first, mmap looks perfect:

- No read/write syscalls
    
- Very fast for simple lookups
    
- Easy implementation
    

But for real databases â†’ **DISASTER**.

---

# ğŸš¨ Problem #1 â€” Transaction Safety

### âŒ â€œOS can flush dirty pages at any time.â€

When using mmap:

- DB writes into memory (not WAL/log)
    
- OS kernel decides _when_ to flush those pages back to disk
    
- YOU CANNOT CONTROL IT
    

This violates **ACID durability**.

### Example:

DB transaction does:

`UPDATE balance SET amount = 100 WHERE user_id = 5;`

Changes go into RAM.  
OS may flush **only half of the page** to disk before the crash.

Result:

- Corrupt page
    
- Partial write
    
- No WAL protection
    

PostgreSQL, MySQL, and most DB engines do **not allow OS-controlled writes** because:

> OS cannot guarantee crash safety â†’ only DBMS can.

### Real-world:

SQLite uses mmap optionally â†’ but **only for reads**, never for writes.

---

# ğŸš¨ Problem #2 â€” I/O Stalls

### âŒ â€œDBMS doesnâ€™t know which pages are in RAM.â€

With mmap:

- DB accesses the memory address
    
- If the page is not in RAM â†’ Page fault
    
- OS loads page from disk
    
- Thread is blocked until disk read finishes â†’ **I/O stall**
    

The DBMS has **no control** over:

- when page faults happen
    
- which pages are prefetched
    
- how to avoid blocking
    

### Why bad?

DBMS usually has smart buffer management:

- LRU / CLOCK / ARC
    
- Prefetch
    
- Read-ahead
    
- Prioritized loading
    
- Background threads
    

With mmap â†’ all of that is impossible.

### Example:

Clicking row in a 20GB table leads to page fault â†’ disk read â†’ thread freeze.

For OLTP systems, stalls = death.

---

# ğŸš¨ Problem #3 â€” Error Handling (SIGBUS)

### âŒ â€œAny memory access can trigger SIGBUS.â€

If the file changes or becomes partially unreadable, mmap can crash the DB:

`SIGBUS: Bus Error (invalid memory access from mmap)`

This happens when:

- The underlying file is truncated
    
- Disk sector becomes unreadable
    
- NFS/network issues
    
- Another process modifies file size
    

### Why dangerous?

mmap maps file offsets â†’ memory addresses.

If DB tries to read:

`address = 0xABCDEF`

But file no longer has that offset â†’ SIGBUS.

DBMS must:

- Catch signal
    
- Unmap
    
- Retry
    
- Log error
    
- Recover
    

Very complicated.  
This is why PostgreSQL **explicitly forbids mmap** for heap and index access.

---

# ğŸš¨ Problem #4 â€” Performance Issues (TLB Shootdowns)

### âŒ â€œOS data structure contention. TLB shootdowns.â€

MMAP uses virtual memory mappings that require:

- page table entries
    
- TLB (Translation Lookaside Buffer) updates
    

When many threads modify mappings (common in large DBs):

`â†’ Kernel must invalidate TLB entries across all CPU cores â†’ Expensive cross-core IPI (inter-processor interrupts) â†’ Performance collapse`

This phenomenon is called **TLB Shootdown**.

### Real effects:

- High latency in multi-core servers
    
- Kernel lock contention
    
- Slowed down syscalls (mmap, munmap)
    
- Terrible scalability
    

Databases like Postgres commonly run on machines with **64â€“256 CPU cores**, so TLB shootdowns are a huge bottleneck.

![[Screenshot 2025-12-11 at 18.57.01.png]]

