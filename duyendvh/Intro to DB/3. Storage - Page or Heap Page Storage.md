https://15445.courses.cs.cmu.edu/fall2024/slides/03-storage1.pdf

![[Screenshot 2025-12-07 at 17.19.48.png]]


![[Screenshot 2025-12-07 at 17.39.12.png]]

## **Storage Engine Comparison of Most Popular Databases**

| Database                       | Primary Storage Engine | Storage Model                             | Update Method                    | MVCC Method                  | Notes                                    |
| ------------------------------ | ---------------------- | ----------------------------------------- | -------------------------------- | ---------------------------- | ---------------------------------------- |
| **PostgreSQL**                 | Heap + WAL             | **Heap pages (unsorted)**                 | Append new tuple version in-page | Tuple header (xmin/xmax)     | VACUUM cleans old versions               |
| **MySQL InnoDB**               | B+Tree                 | **Clustered B+Tree** (sorted by PK)       | In-place update + undo log       | Undo log                     | Secondary indexes point to PK            |
| **Oracle**                     | Heap + Undo            | **Heap pages**                            | In-place update + undo segments  | Undo + SCN                   | Very sophisticated MVCC & block metadata |
| **SQLite**                     | B+Tree                 | **Single B+Tree file**                    | In-place                         | Copy-on-write (for WAL mode) | Simple, embedded                         |
| **MongoDB WiredTiger**         | LSM-tree (WiredTiger)  | **LSM-tree or B+Tree**                    | Append-only memtable ‚Üí SST       | Document-level timestamps    | Checkpoint + journal                     |
| **Cassandra**                  | LSM-tree               | **SSTables + memtables**                  | Append-only                      | Timestamp-based              | Log-structured, wide-column              |
| **RocksDB**                    | LSM-tree               | **SSTables + memtables**                  | Append-only                      | Sequence numbers             | Used by many modern systems              |
| **ClickHouse**                 | Columnar               | **Compressed column segments**            | Append-only parts                | Snapshot timestamps          | Merge-tree compaction                    |
| **DuckDB**                     | Columnar               | **Column segments (vectorized)**          | Append new chunks                | MVCC per vector              | Embedded OLAP                            |
| **BigQuery**                   | Columnar + Log         | **Column stripes + log**                  | Append-only                      | Snapshot-based               | Fully managed                            |
| **Snowflake**                  | Columnar               | **Micro-partitions**                      | Append-only                      | Time-travel metadata         | Heavy metadata indexing                  |
| **ElasticSearch / OpenSearch** | LSM-like               | **Segment files**                         | Append-only segments             | Doc-level versions           | Segment merges                           |
| **Redis**                      | In-memory              | **RAM-based dict + log**                  | In-place update in RAM           | N/A                          | AOF (log) or RDB snapshot                |
| **Couchbase**                  | LSM-like               | **Append-only data files + B+Tree index** | Append                           | Metadata-based MVCC          | Log-structured                           |

![[Screenshot 2025-12-07 at 17.45.47.png]]
![[Screenshot 2025-12-07 at 17.46.13.png]]

![[Screenshot 2025-12-07 at 17.41.54.png]]


![[Screenshot 2025-12-07 at 18.19.47.png]]

![[Screenshot 2025-12-07 at 18.17.55.png]]

## Why Deleting a Tuple Leaves Holes

If you append tuples sequentially:

`| T1 | T2 | T3 | T4 | free |`

After you DELETE T2:

`| T1 | ‚Äîhole‚Äî | T3 | T4 | free |`

The page now has:

- Hole in the middle
    
- You **cannot shift T3, T4** left ‚Üí that would break:
    
    - index pointers
        
    - row references
        
    - transaction visibility
        
    - MVCC chain links
        
- So the hole remains.
    

---

## How Real DBs Solve It ‚Üí **Line Pointer Table**

A page is NOT ‚Äújust tuples‚Äù.

It looks like this:

`+-------------------------+ | Page Header             | +-------------------------+ | Line Pointer Table      |  <‚Äî fixed-size array of pointers | LP1 | LP2 | LP3 | ...   | +-------------------------+ | Tuples stored from      | | the bottom of page up   | | ... T3 ... T4 ...       | +-------------------------+`

---

### **DELETE does not remove tuple data**

Instead:

1. DB marks the tuple as **dead** using a flag in tuple header
    
2. DB sets the **line pointer to "unused"**
    
3. DB may optionally **recycle the tuple's space** later (vacuuming / coalescing)
    

The tuple itself can remain physically in place.

‚û° **Indexes still have valid TIDs (tuple IDs)** that point to line pointers.  
‚û° Line pointer indirection avoids breaking references.

---

## How to Reuse Space After Delete (Fixing Holes)

### PostgreSQL Method:

- **VACUUM** marks dead tuples and recovers space **inside the page**.
    
- Does _not_ move surviving tuples (to avoid breaking TIDs).
    
- Frees unused tuple space for future INSERTs **in the same page**.
    

### Oracle Method:

- Oracle uses **ITL slots and UNDO**.
    
- When a row is deleted:
    
    - The row piece is marked as deleted
        
    - Space becomes reusable after transaction commit
        
- Oracle may **defragment blocks** internally, because Oracle uses **rowids** that point to (file#, block#, slot#), not direct byte offsets.
    

### General Strategy:

- Space is tracked in the page
    
- When a new tuple is inserted:
    
    - Page checks for **free holes first**
        
    - Only if no hole fits ‚Üí append at end

## How DB Handles Updates That Grow the Tuple (UPDATE With Bigger Size)

Suppose:

`UPDATE users SET bio = <larger string>`

If new tuple is larger than existing space:

### PostgreSQL:

- It **creates a new tuple version** (MVCC)
    
- Old version becomes dead
    
- Line pointer updated to point to new version
    
- May store varlen attributes in TOAST
    

### Oracle:

- Uses **UNDO** to store old image
    
- Row migration:
    
    - If the row grows too large, Oracle moves it to another block
        
    - Leaves a forwarding pointer in original block


![[Screenshot 2025-12-07 at 18.56.31.png]]
# üü© **1. ORACLE BLOCK (SELF-CONTAINED)**

### Example: A single Oracle table block with 3 rows
![[Screenshot 2025-12-07 at 18.28.22.png]]
### ‚≠ê Explanation: Why is Oracle self-contained?

Oracle stores **all the following inside the block**:

|Component|Stored in Block?|Why it matters|
|---|---|---|
|Lock metadata|**Yes**|Allows row-level locking without external structures|
|Visibility (SCN)|**Yes**|Oracle can determine row visibility from block only|
|Undo pointer|**Yes**|Can reconstruct old versions without scanning table|
|Object metadata|**Yes**|Block knows which table it belongs to|
|Slot/Row map|**Yes**|Fast access to rows|
|Checksum|Yes|Reliability|

### ‚úî Oracle can interpret a block **with no external lookups**

‚Üí No VACUUM  
‚Üí Fast MVCC  
‚Üí High concurrency  
‚Üí Minimal overhead
---

# üü• **2. POSTGRESQL PAGE (NOT SELF-CONTAINED)**

### Example: PostgreSQL heap page with 3 tuples

![[Screenshot 2025-12-07 at 18.29.34.png]]
### üö® Explanation: Why PostgreSQL pages are NOT self-contained

|Component|Stored in Page?|External Source|
|---|---|---|
|Lock metadata|**No**|External lock manager|
|Visibility check|‚ùå No|Needs CLOG (commit log)|
|Undo pointer|‚ùå No|Uses tuple versioning instead|
|Commit status|‚ùå No|CLOG / pg_xact|
|Snapshot visibility|‚ùå No|Needs active transaction snapshot|
|Dead tuple cleanup|‚ùå No|VACUUM required|

### ‚ùå PostgreSQL needs:

- page **+** commit log
    
- page **+** transaction snapshot
    
- page **+** lock manager
    
- VACUUM to clean up dead tuples
    

This makes PostgreSQL **not self-contained** and adds overhead.

---

# üü¶ **3. MYSQL INNODB PAGE (PARTIALLY SELF-CONTAINED)**

### Example: InnoDB data page (16KB)
![[Screenshot 2025-12-07 at 18.30.50.png]]

### ‚≠ê Explanation: Why InnoDB is "semi" self-contained:

|Component|Stored in Page?|Notes|
|---|---|---|
|Undo pointer|**Yes**|Like Oracle|
|Transaction ID|Yes|Last updated by trx|
|Visibility info|Partial|Uses undo + trx_id|
|Lock info|‚ùå No|Stored in lock hash outside page|
|Object metadata|‚ùå No|Requires dictionary lookup|

### ‚úî Can reconstruct old versions (good MVCC)

### ‚ùå Needs external lock manager (not fully self-contained)




# üß† **1. How PostgreSQL Organizes Data Internally**

PostgreSQL stores its data using **a layered structure**:

`Table ‚Üí Pages (Blocks) ‚Üí Tuples (Rows)`

### ‚úÖ **A. Table is stored as many 8 KB pages**

- Every table (and index) on disk is broken into fixed-size blocks.
    
- By default: **1 page = 8 KB**
    

Example:  
If you have a 1 GB table ‚Üí it contains ~131,000 pages.

### Why pages?

- Easy to cache.
    
- Easy to load from disk.
    
- Easy to manage during vacuum, MVCC, WAL.
    

---

### ‚úÖ **B. Shared Buffers = Internal PostgreSQL Cache (in RAM)**

PostgreSQL does **not** read rows directly into memory.

Instead:

1. PostgreSQL requests a **page** (8 KB)
    
2. Page is loaded into **shared_buffers**
    
3. All future queries use this page from memory‚Äî**no disk**.
    

---

### üß† **C. Shared Buffers acts like PostgreSQL‚Äôs ‚Äúbrain memory‚Äù**

- It‚Äôs a **fixed-size RAM area** configured by:
    
    `SHOW shared_buffers;`
    
    Example: `4GB`
    
- It stores recently used pages of:
    
    - Tables
        
    - Indexes
        
    - Toast
        
    - Heap pages
        
    - Visibility maps
        

---

# üìå **2. Why PostgreSQL reads MOST data from memory**

![[Screenshot 2025-12-07 at 18.32.39.png]]

## ‚úî Layer 1: PostgreSQL Cache (shared_buffers)

- Holds frequently accessed pages.
    
- Most queries are served from here.
    
- Reduces disk reads dramatically.
    

## ‚úî Layer 2: OS Page Cache

If a page is not in shared_buffers:

- PostgreSQL asks OS to read the page.
    
- OS loads it into **page cache** (RAM).
    
- So even disk reads are actually mem reads if OS cached it.
    

---

# üéØ **Result: even when PostgreSQL reads "from disk", it may still be from RAM**

This is why PostgreSQL can often achieve > 99% cache hit ratio.

Check it:

`SELECT   sum(blks_hit) * 100.0 /   nullif(sum(blks_hit + blks_read), 0) AS cache_hit_ratio FROM pg_stat_database;`

---

# üöÄ 3. **What Exactly Is a Buffer?**

A **buffer** = one 8 KB page of a table/index loaded into memory.

A **buffer** contains:

- Header (page metadata)
    
- Rows (tuples)
    
- Free space
    
- Visibility info (MVCC)
    

When you run a SELECT:

1. PostgreSQL checks if the page is in shared buffers.
    
2. If YES ‚Üí **memory hit** (very fast)
    
3. If NO ‚Üí read page from disk ‚Üí place it into a buffer.
    

---

# üß† 4. **Why PostgreSQL uses fixed-size (8 KB) pages**

Advantages:

### ‚úî Predictability (performance)

- Always reads/write full 8 KB chunks.
    
- Very efficient with SSD block sizes.
    

### ‚úî Easy caching

- LRU-like behavior for frequently accessed pages.
    
- Predictable memory usage.
    

### ‚úî MVCC works better

- Row versions stored inside pages.
    
- Vacuum can track free space page-by-page.
    

---

# üî• 5. Example: How a SELECT works under the hood

Let's say you run:

`SELECT * FROM users WHERE id = 10;`

### Step-by-step:

1. Planner decides it needs index `users_pkey`
    
2. PostgreSQL loads the index page(s) into buffers
    
3. Using index ‚Üí finds heap page number
    
4. PostgreSQL loads that heap page into buffers
    
5. Row is returned ‚Üí **all future reads now served from memory**
    

This is why PostgreSQL becomes extremely fast **after warm-up**.

---

# üß† 6. How PostgreSQL Keeps Hot Data in Memory

Shared buffers grows hotter by:

### ‚úî Frequently accessed pages stay longer

Because they stay in LRU end of buffer chain.

### ‚úî Rarely accessed pages get evicted

When shared_buffers is full, the least recently used pages are removed.

---

# üß™ 7. How to see what is in memory (buffers)

`SELECT * FROM pg_buffercache LIMIT 20;`

(Needs extension `pg_buffercache`)

You can see:

- Which tables are cached
    
- Which indexes are cached
    
- How many pages are cached per relation
# 
üöÄ 1. **Storage & Table Size Monitoring**

## **üìå pg_database_size(name)**

**Concept:**  
Shows how much space a database consumes on disk.

**Why it matters:**  
Use it to detect which database is growing too fast or which one is too big.

**Example**

`SELECT pg_size_pretty(pg_database_size('mydb'));`

‚Üí Returns human-readable size like `12 GB`.

---

## **üìå pg_relation_size(object)**

**Concept:**  
Returns **size of a single table OR index only** (WITHOUT children like TOAST or indexes).

**Useful when:**  
You want to know if a table or index is getting too big.

**Example**

`SELECT pg_size_pretty(pg_relation_size('orders'));`

---

## **üìå pg_total_relation_size(object)**

**Concept:**  
Returns **table + indexes + toast + toast indexes**.  
This is the **real total size** of a table.

**Example**

`SELECT pg_size_pretty(pg_total_relation_size('orders'));`

‚Üí Use this to see how large a table REALLY is.

---

## **üìå pg_indexes_size(table)**

**Concept:**  
Shows total storage used **by all indexes** on a table.

**Why important:**  
Indexes can grow silently and consume more space than the table itself.

**Example**

`SELECT pg_size_pretty(pg_indexes_size('orders'));`

---

## **üìå pg_table_size(table)**

**Concept:**  
Shows size of table data (**excluding indexes**)  
but **including TOAST** (large text/binary).

**Example**

`SELECT pg_size_pretty(pg_table_size('orders'));`

---

## **üìå pg_tablespace_size(name)**

**Concept:**  
A tablespace is a directory on disk where data is stored.  
This function shows how much data is inside it.

**Example**

`SELECT pg_size_pretty(pg_tablespace_size('pg_default'));`

---

# üöÄ 2. **Cache & Buffer Monitoring**

## **üìå Cache Hit Ratio**

**Concept:**  
Measures how often PostgreSQL reads data **from memory (fast)**  
instead of **disk (slow)**.

High-performance DBs have **> 99% hit ratio**.

**Example**

`SELECT   sum(blks_hit) / nullif(sum(blks_hit + blks_read), 0) AS cache_hit_ratio FROM pg_stat_database;`

---

## **üìå pg_statio_user_tables**

**Concept:**  
Shows how many blocks were read from:

- **disk** (`heap_blks_read`)
    
- **cache** (`heap_blks_hit`)
    

**Use case:**  
Find tables that cause disk I/O.

**Example**

`SELECT relname, heap_blks_read, heap_blks_hit FROM pg_statio_user_tables;`

---

# üöÄ 3. **Index Monitoring**

## **üìå pg_stat_user_indexes**

**Concept:**  
Tracks how often an index was used (`idx_scan`).

**Why:**  
Unused indexes slow down writes and waste disk.

**Example ‚Äî find unused indexes**

`SELECT     indexrelname, idx_scan FROM pg_stat_user_indexes WHERE idx_scan = 0;`

---

## **üìå High Sequential Scans = Missing index**

**Concept:**  
If a table is scanned sequentially (`seq_scan`) more than using indexes (`idx_scan`),  
it suggests indexes are missing or are not selective.

**Example**

`SELECT relname, seq_scan, idx_scan FROM pg_stat_user_tables WHERE seq_scan > idx_scan;`

---

# üöÄ 4. **Vacuum / Autovacuum Monitoring**

## **üìå n_dead_tup (dead tuples)**

**Concept:**  
Dead rows created by UPDATE/DELETE.  
PostgreSQL MUST vacuum them to free space.

**Example**

`SELECT relname, n_dead_tup FROM pg_stat_user_tables ORDER BY n_dead_tup DESC;`

---

## **üìå last_vacuum / last_autovacuum**

**Concept:**  
Shows when PostgreSQL last cleaned the table.

**Example**

`SELECT relname, last_vacuum, last_autovacuum FROM pg_stat_user_tables;`

---

## **üìå pgstattuple (needs extension)**

**Concept:**  
Estimates table **bloat** ‚Äî wasted space due to dead tuples.

**Example**

`SELECT * FROM pgstattuple('orders');`

---

# üöÄ 5. **WAL / Checkpoint Monitoring**

## **üìå pg_stat_bgwriter**

**Concept:**  
Shows how often PostgreSQL performs checkpoints and buffer writes.  
Used to detect I/O pressure.

**Example**

`SELECT * FROM pg_stat_bgwriter;`

---

# üöÄ 6. **Lock Monitoring**

## **üìå pg_stat_activity (wait events)**

**Concept:**  
Shows what each backend is doing and if it is **waiting** on a lock.

**Example**

`SELECT     pid, usename, wait_event_type, wait_event, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL;`

---

## **üìå pg_locks**

**Concept:**  
Shows all locks currently held (row locks, table locks, etc.)

**Example**

`SELECT * FROM pg_locks;`

---

# üöÄ 7. **Connection Monitoring**

## **üìå Number of connections**

**Concept:**  
Tracks all active connections to the DB.

**Example**

`SELECT datname, count(*) FROM pg_stat_activity GROUP BY datname;`

---

# üöÄ 8. **Slow Query Monitoring**

## **üìå pg_stat_statements**

**Concept:**  
Tracks execution time, frequency, and total cost of each query.

**Why:**  
Most important performance extension.

**Example ‚Äî slowest queries**

`SELECT query, mean_exec_time, calls FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 20;`

---

# üöÄ 9. **Table Statistics**

**Concept:**  
Shows table insert/update/delete activity and dead/live tuples.

**Example**

`SELECT     relname,     n_tup_ins, n_tup_upd, n_tup_del,     n_live_tup, n_dead_tup FROM pg_stat_user_tables;`

---

# üöÄ 10. **Freeze / XID Monitoring (pg_relation_*)**

## **üìå pg_relation_frozen_xid(oid)**

**Concept:**  
PostgreSQL uses transaction IDs (XIDs).  
If old rows aren't vacuum-frozen in time, **transaction wraparound** can crash the DB.

This function shows the oldest unfrozen transaction per table.

**Example**

`SELECT relname, pg_relation_frozen_xid(oid) FROM pg_class WHERE relkind='r';`

---

# üöÄ 11. **Free Space Monitoring**

## **üìå pg_freespace(rel)**

Requires: `pg_freespacemap`

**Concept:**  
Shows how much free space is available in each page of a table.

**Use case:**  
Detect tables with fragmentation.

**Example**

`SELECT * FROM pg_freespace('orders') LIMIT 10;`

---