https://15445.courses.cs.cmu.edu/fall2024/slides/03-storage1.pdf

![[Screenshot 2025-12-07 at 17.19.48.png]]


![[Screenshot 2025-12-07 at 17.39.12.png]]
![[Screenshot 2025-12-07 at 17.45.47.png]]
![[Screenshot 2025-12-07 at 17.46.13.png]]

![[Screenshot 2025-12-07 at 17.41.54.png]]


![[Screenshot 2025-12-07 at 18.19.47.png]]

![[Screenshot 2025-12-07 at 18.17.55.png]]

## Why Deleting a Tuple Leaves Holes

If you append tuples sequentially:

`| T1 | T2 | T3 | T4 | free |`

After you DELETE T2:

`| T1 | â€”holeâ€” | T3 | T4 | free |`

The page now has:

- Hole in the middle
    
- You **cannot shift T3, T4** left â†’ that would break:
    
    - index pointers
        
    - row references
        
    - transaction visibility
        
    - MVCC chain links
        
- So the hole remains.
    

---

## How Real DBs Solve It â†’ **Line Pointer Table**

A page is NOT â€œjust tuplesâ€.

It looks like this:

`+-------------------------+ | Page Header             | +-------------------------+ | Line Pointer Table      |  <â€” fixed-size array of pointers | LP1 | LP2 | LP3 | ...   | +-------------------------+ | Tuples stored from      | | the bottom of page up   | | ... T3 ... T4 ...       | +-------------------------+`

---

### **DELETE does not remove tuple data**

Instead:

1. DB marks the tuple as **dead** using a flag in tuple header
    
2. DB sets the **line pointer to "unused"**
    
3. DB may optionally **recycle the tuple's space** later (vacuuming / coalescing)
    

The tuple itself can remain physically in place.

â¡ **Indexes still have valid TIDs (tuple IDs)** that point to line pointers.  
â¡ Line pointer indirection avoids breaking references.

---

## How to Reuse Space After Delete (Fixing Holes)

### PostgreSQL Method:

- **VACUUM** marks dead tuples and recovers space **inside the page**.
    
- Does _not_ move surviving tuples (to avoid breaking TIDs).
    
- Frees unused tuple space for future INSERTs **in the same page**.
    

### Oracle Method:

- Oracle uses **ITL slots and UNDO**.
    
- When a row is deleted:
    
    - The row piece is marked as deleted
        
    - Space becomes reusable after transaction commit
        
- Oracle may **defragment blocks** internally, because Oracle uses **rowids** that point to (file#, block#, slot#), not direct byte offsets.
    

### General Strategy:

- Space is tracked in the page
    
- When a new tuple is inserted:
    
    - Page checks for **free holes first**
        
    - Only if no hole fits â†’ append at end

## How DB Handles Updates That Grow the Tuple (UPDATE With Bigger Size)

Suppose:

`UPDATE users SET bio = <larger string>`

If new tuple is larger than existing space:

### PostgreSQL:

- It **creates a new tuple version** (MVCC)
    
- Old version becomes dead
    
- Line pointer updated to point to new version
    
- May store varlen attributes in TOAST
    

### Oracle:

- Uses **UNDO** to store old image
    
- Row migration:
    
    - If the row grows too large, Oracle moves it to another block
        
    - Leaves a forwarding pointer in original block


![[Screenshot 2025-12-07 at 18.56.31.png]]
# ğŸŸ© **1. ORACLE BLOCK (SELF-CONTAINED)**

### Example: A single Oracle table block with 3 rows
![[Screenshot 2025-12-07 at 18.28.22.png]]
### â­ Explanation: Why is Oracle self-contained?

Oracle stores **all the following inside the block**:

|Component|Stored in Block?|Why it matters|
|---|---|---|
|Lock metadata|**Yes**|Allows row-level locking without external structures|
|Visibility (SCN)|**Yes**|Oracle can determine row visibility from block only|
|Undo pointer|**Yes**|Can reconstruct old versions without scanning table|
|Object metadata|**Yes**|Block knows which table it belongs to|
|Slot/Row map|**Yes**|Fast access to rows|
|Checksum|Yes|Reliability|

### âœ” Oracle can interpret a block **with no external lookups**

â†’ No VACUUM  
â†’ Fast MVCC  
â†’ High concurrency  
â†’ Minimal overhead
---

# ğŸŸ¥ **2. POSTGRESQL PAGE (NOT SELF-CONTAINED)**

### Example: PostgreSQL heap page with 3 tuples

![[Screenshot 2025-12-07 at 18.29.34.png]]
### ğŸš¨ Explanation: Why PostgreSQL pages are NOT self-contained

|Component|Stored in Page?|External Source|
|---|---|---|
|Lock metadata|**No**|External lock manager|
|Visibility check|âŒ No|Needs CLOG (commit log)|
|Undo pointer|âŒ No|Uses tuple versioning instead|
|Commit status|âŒ No|CLOG / pg_xact|
|Snapshot visibility|âŒ No|Needs active transaction snapshot|
|Dead tuple cleanup|âŒ No|VACUUM required|

### âŒ PostgreSQL needs:

- page **+** commit log
    
- page **+** transaction snapshot
    
- page **+** lock manager
    
- VACUUM to clean up dead tuples
    

This makes PostgreSQL **not self-contained** and adds overhead.

---

# ğŸŸ¦ **3. MYSQL INNODB PAGE (PARTIALLY SELF-CONTAINED)**

### Example: InnoDB data page (16KB)
![[Screenshot 2025-12-07 at 18.30.50.png]]

### â­ Explanation: Why InnoDB is "semi" self-contained:

|Component|Stored in Page?|Notes|
|---|---|---|
|Undo pointer|**Yes**|Like Oracle|
|Transaction ID|Yes|Last updated by trx|
|Visibility info|Partial|Uses undo + trx_id|
|Lock info|âŒ No|Stored in lock hash outside page|
|Object metadata|âŒ No|Requires dictionary lookup|

### âœ” Can reconstruct old versions (good MVCC)

### âŒ Needs external lock manager (not fully self-contained)




# ğŸ§  **1. How PostgreSQL Organizes Data Internally**

PostgreSQL stores its data using **a layered structure**:

`Table â†’ Pages (Blocks) â†’ Tuples (Rows)`

### âœ… **A. Table is stored as many 8 KB pages**

- Every table (and index) on disk is broken into fixed-size blocks.
    
- By default: **1 page = 8 KB**
    

Example:  
If you have a 1 GB table â†’ it contains ~131,000 pages.

### Why pages?

- Easy to cache.
    
- Easy to load from disk.
    
- Easy to manage during vacuum, MVCC, WAL.
    

---

### âœ… **B. Shared Buffers = Internal PostgreSQL Cache (in RAM)**

PostgreSQL does **not** read rows directly into memory.

Instead:

1. PostgreSQL requests a **page** (8 KB)
    
2. Page is loaded into **shared_buffers**
    
3. All future queries use this page from memoryâ€”**no disk**.
    

---

### ğŸ§  **C. Shared Buffers acts like PostgreSQLâ€™s â€œbrain memoryâ€**

- Itâ€™s a **fixed-size RAM area** configured by:
    
    `SHOW shared_buffers;`
    
    Example: `4GB`
    
- It stores recently used pages of:
    
    - Tables
        
    - Indexes
        
    - Toast
        
    - Heap pages
        
    - Visibility maps
        

---

# ğŸ“Œ **2. Why PostgreSQL reads MOST data from memory**

![[Screenshot 2025-12-07 at 18.32.39.png]]

## âœ” Layer 1: PostgreSQL Cache (shared_buffers)

- Holds frequently accessed pages.
    
- Most queries are served from here.
    
- Reduces disk reads dramatically.
    

## âœ” Layer 2: OS Page Cache

If a page is not in shared_buffers:

- PostgreSQL asks OS to read the page.
    
- OS loads it into **page cache** (RAM).
    
- So even disk reads are actually mem reads if OS cached it.
    

---

# ğŸ¯ **Result: even when PostgreSQL reads "from disk", it may still be from RAM**

This is why PostgreSQL can often achieve > 99% cache hit ratio.

Check it:

`SELECT   sum(blks_hit) * 100.0 /   nullif(sum(blks_hit + blks_read), 0) AS cache_hit_ratio FROM pg_stat_database;`

---

# ğŸš€ 3. **What Exactly Is a Buffer?**

A **buffer** = one 8 KB page of a table/index loaded into memory.

A **buffer** contains:

- Header (page metadata)
    
- Rows (tuples)
    
- Free space
    
- Visibility info (MVCC)
    

When you run a SELECT:

1. PostgreSQL checks if the page is in shared buffers.
    
2. If YES â†’ **memory hit** (very fast)
    
3. If NO â†’ read page from disk â†’ place it into a buffer.
    

---

# ğŸ§  4. **Why PostgreSQL uses fixed-size (8 KB) pages**

Advantages:

### âœ” Predictability (performance)

- Always reads/write full 8 KB chunks.
    
- Very efficient with SSD block sizes.
    

### âœ” Easy caching

- LRU-like behavior for frequently accessed pages.
    
- Predictable memory usage.
    

### âœ” MVCC works better

- Row versions stored inside pages.
    
- Vacuum can track free space page-by-page.
    

---

# ğŸ”¥ 5. Example: How a SELECT works under the hood

Let's say you run:

`SELECT * FROM users WHERE id = 10;`

### Step-by-step:

1. Planner decides it needs index `users_pkey`
    
2. PostgreSQL loads the index page(s) into buffers
    
3. Using index â†’ finds heap page number
    
4. PostgreSQL loads that heap page into buffers
    
5. Row is returned â†’ **all future reads now served from memory**
    

This is why PostgreSQL becomes extremely fast **after warm-up**.

---

# ğŸ§  6. How PostgreSQL Keeps Hot Data in Memory

Shared buffers grows hotter by:

### âœ” Frequently accessed pages stay longer

Because they stay in LRU end of buffer chain.

### âœ” Rarely accessed pages get evicted

When shared_buffers is full, the least recently used pages are removed.

---

# ğŸ§ª 7. How to see what is in memory (buffers)

`SELECT * FROM pg_buffercache LIMIT 20;`

(Needs extension `pg_buffercache`)

You can see:

- Which tables are cached
    
- Which indexes are cached
    
- How many pages are cached per relation
# 
ğŸš€ 1. **Storage & Table Size Monitoring**

## **ğŸ“Œ pg_database_size(name)**

**Concept:**  
Shows how much space a database consumes on disk.

**Why it matters:**  
Use it to detect which database is growing too fast or which one is too big.

**Example**

`SELECT pg_size_pretty(pg_database_size('mydb'));`

â†’ Returns human-readable size like `12 GB`.

---

## **ğŸ“Œ pg_relation_size(object)**

**Concept:**  
Returns **size of a single table OR index only** (WITHOUT children like TOAST or indexes).

**Useful when:**  
You want to know if a table or index is getting too big.

**Example**

`SELECT pg_size_pretty(pg_relation_size('orders'));`

---

## **ğŸ“Œ pg_total_relation_size(object)**

**Concept:**  
Returns **table + indexes + toast + toast indexes**.  
This is the **real total size** of a table.

**Example**

`SELECT pg_size_pretty(pg_total_relation_size('orders'));`

â†’ Use this to see how large a table REALLY is.

---

## **ğŸ“Œ pg_indexes_size(table)**

**Concept:**  
Shows total storage used **by all indexes** on a table.

**Why important:**  
Indexes can grow silently and consume more space than the table itself.

**Example**

`SELECT pg_size_pretty(pg_indexes_size('orders'));`

---

## **ğŸ“Œ pg_table_size(table)**

**Concept:**  
Shows size of table data (**excluding indexes**)  
but **including TOAST** (large text/binary).

**Example**

`SELECT pg_size_pretty(pg_table_size('orders'));`

---

## **ğŸ“Œ pg_tablespace_size(name)**

**Concept:**  
A tablespace is a directory on disk where data is stored.  
This function shows how much data is inside it.

**Example**

`SELECT pg_size_pretty(pg_tablespace_size('pg_default'));`

---

# ğŸš€ 2. **Cache & Buffer Monitoring**

## **ğŸ“Œ Cache Hit Ratio**

**Concept:**  
Measures how often PostgreSQL reads data **from memory (fast)**  
instead of **disk (slow)**.

High-performance DBs have **> 99% hit ratio**.

**Example**

`SELECT   sum(blks_hit) / nullif(sum(blks_hit + blks_read), 0) AS cache_hit_ratio FROM pg_stat_database;`

---

## **ğŸ“Œ pg_statio_user_tables**

**Concept:**  
Shows how many blocks were read from:

- **disk** (`heap_blks_read`)
    
- **cache** (`heap_blks_hit`)
    

**Use case:**  
Find tables that cause disk I/O.

**Example**

`SELECT relname, heap_blks_read, heap_blks_hit FROM pg_statio_user_tables;`

---

# ğŸš€ 3. **Index Monitoring**

## **ğŸ“Œ pg_stat_user_indexes**

**Concept:**  
Tracks how often an index was used (`idx_scan`).

**Why:**  
Unused indexes slow down writes and waste disk.

**Example â€” find unused indexes**

`SELECT     indexrelname, idx_scan FROM pg_stat_user_indexes WHERE idx_scan = 0;`

---

## **ğŸ“Œ High Sequential Scans = Missing index**

**Concept:**  
If a table is scanned sequentially (`seq_scan`) more than using indexes (`idx_scan`),  
it suggests indexes are missing or are not selective.

**Example**

`SELECT relname, seq_scan, idx_scan FROM pg_stat_user_tables WHERE seq_scan > idx_scan;`

---

# ğŸš€ 4. **Vacuum / Autovacuum Monitoring**

## **ğŸ“Œ n_dead_tup (dead tuples)**

**Concept:**  
Dead rows created by UPDATE/DELETE.  
PostgreSQL MUST vacuum them to free space.

**Example**

`SELECT relname, n_dead_tup FROM pg_stat_user_tables ORDER BY n_dead_tup DESC;`

---

## **ğŸ“Œ last_vacuum / last_autovacuum**

**Concept:**  
Shows when PostgreSQL last cleaned the table.

**Example**

`SELECT relname, last_vacuum, last_autovacuum FROM pg_stat_user_tables;`

---

## **ğŸ“Œ pgstattuple (needs extension)**

**Concept:**  
Estimates table **bloat** â€” wasted space due to dead tuples.

**Example**

`SELECT * FROM pgstattuple('orders');`

---

# ğŸš€ 5. **WAL / Checkpoint Monitoring**

## **ğŸ“Œ pg_stat_bgwriter**

**Concept:**  
Shows how often PostgreSQL performs checkpoints and buffer writes.  
Used to detect I/O pressure.

**Example**

`SELECT * FROM pg_stat_bgwriter;`

---

# ğŸš€ 6. **Lock Monitoring**

## **ğŸ“Œ pg_stat_activity (wait events)**

**Concept:**  
Shows what each backend is doing and if it is **waiting** on a lock.

**Example**

`SELECT     pid, usename, wait_event_type, wait_event, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL;`

---

## **ğŸ“Œ pg_locks**

**Concept:**  
Shows all locks currently held (row locks, table locks, etc.)

**Example**

`SELECT * FROM pg_locks;`

---

# ğŸš€ 7. **Connection Monitoring**

## **ğŸ“Œ Number of connections**

**Concept:**  
Tracks all active connections to the DB.

**Example**

`SELECT datname, count(*) FROM pg_stat_activity GROUP BY datname;`

---

# ğŸš€ 8. **Slow Query Monitoring**

## **ğŸ“Œ pg_stat_statements**

**Concept:**  
Tracks execution time, frequency, and total cost of each query.

**Why:**  
Most important performance extension.

**Example â€” slowest queries**

`SELECT query, mean_exec_time, calls FROM pg_stat_statements ORDER BY mean_exec_time DESC LIMIT 20;`

---

# ğŸš€ 9. **Table Statistics**

**Concept:**  
Shows table insert/update/delete activity and dead/live tuples.

**Example**

`SELECT     relname,     n_tup_ins, n_tup_upd, n_tup_del,     n_live_tup, n_dead_tup FROM pg_stat_user_tables;`

---

# ğŸš€ 10. **Freeze / XID Monitoring (pg_relation_*)**

## **ğŸ“Œ pg_relation_frozen_xid(oid)**

**Concept:**  
PostgreSQL uses transaction IDs (XIDs).  
If old rows aren't vacuum-frozen in time, **transaction wraparound** can crash the DB.

This function shows the oldest unfrozen transaction per table.

**Example**

`SELECT relname, pg_relation_frozen_xid(oid) FROM pg_class WHERE relkind='r';`

---

# ğŸš€ 11. **Free Space Monitoring**

## **ğŸ“Œ pg_freespace(rel)**

Requires: `pg_freespacemap`

**Concept:**  
Shows how much free space is available in each page of a table.

**Use case:**  
Detect tables with fragmentation.

**Example**

`SELECT * FROM pg_freespace('orders') LIMIT 10;`

---